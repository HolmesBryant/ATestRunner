/**
 * @author Holmes Bryant <https://github.com/HolmesBryant>
 * @version 1.0.0
 * @license MIT
 */
class t{metaURL;onlyFailed=!1;#t="console";#e="pass";#s=[];constructor(t){this.metaURL=t,this.info=this.info.bind(this),this.test=this.test.bind(this),this.when=this.when.bind(this),this.profile=this.profile.bind(this)}async benchmark(t,e=1,s=null,...n){const i=performance.now();for(let i=0;i<e;i++)await t.apply(s,n);return performance.now()-i}equal(t,e){const s=new Map;return function t(e,n){if(e===n)return!0;if(null===e||"object"!=typeof e||null===n||"object"!=typeof n)return!1;if(s.has(e)&&s.get(e)===n)return!0;if(s.set(e,n),e instanceof Date&&n instanceof Date)return e.getTime()===n.getTime();if(e instanceof RegExp&&n instanceof RegExp)return e.toString()===n.toString();if(e.constructor!==n.constructor)return!1;if(e instanceof Map&&n instanceof Map){if(e.size!==n.size)return!1;for(const[s,i]of e.entries())if(!n.has(s)||!t(i,n.get(s)))return!1;return!0}if(e instanceof Set&&n instanceof Set){if(e.size!==n.size)return!1;const s=[...n.values()];for(const n of e.values())if(!s.some(e=>t(n,e)))return!1;return!0}if(Array.isArray(e)){if(e.length!==n.length)return!1;for(let s=0;s<e.length;s++)if(!t(e[s],n[s]))return!1;return!0}const i=Object.keys(e);if(i.length!==Object.keys(n).length)return!1;for(const s of i)if(!Object.prototype.hasOwnProperty.call(n,s)||!t(e[s],n[s]))return!1;return!0}(t,e)}*genCombos(t={}){const e=Object.keys(t),s=Object.values(t);yield*function*t(n,i){if(n===e.length)return void(yield{...i});const o=e[n],r=s[n];if(Array.isArray(r))for(const e of r)i[o]=e,yield*t(n+1,i);else i[o]=r,yield*t(n+1,i)}(0,{})}info(t){this.#s.push({type:"info",payload:{message:t}})}async profile(t,e,s=this,...n){let i=this[t];if(!i)switch(t){case"executeTest":i=this.#n;break;case"getLine":i=this.#i;break;case"getStyle":i=this.#o;break;case"printResult":i=this.#r}return this.benchmark(i,e,s,...n)}async run(){const t=this.#s.length;let e=0;this.#l(0,t);const s=this.output,n=this.#s.map(s=>{let n;return"info"===s.type?n=Promise.resolve({type:"info",message:s.payload.message}):"test"===s.type&&(n=this.#n(s.payload)),n.then(s=>(e++,this.#l(e,t),s))}),i=await Promise.all(n);for(const t of i)"fail"!==t.verdict&&"error"!==t.verdict||(this.#e="fail"),"info"===t.type?this.onlyFailed||this.#r(s,t.message,"info"):"test"===t.type&&this.#r(s,t.gist,t.verdict,t.resolvedTestResult,t.expect,t.line);this.#c(),this.#r(s,"All tests completed","done")}spyOn(t,e){const s=t[e];if("function"!=typeof s)throw new Error(`${e} is not a function`);const n={callCount:0,calls:[],restore:()=>{t[e]=s}};return t[e]=function(...t){return n.callCount++,n.calls.push(t),s.apply(this,t)},n}test(t,e,s){const n=this.metaURL?this.#i():null;this.#s.push({type:"test",payload:{gist:t,testFn:e,expect:s,line:n}})}async wait(t){return new Promise(e=>setTimeout(e,t))}async when(t,e=1e3,s=100){const n=Date.now();let i;for(i="function"==typeof t?async()=>t():async()=>t;;){if(Date.now()-n>=e)return await i();try{const t=await i();if(t)return t}catch(t){throw t}await this.wait(s)}}async#n(t){const{gist:e,testFn:s,expect:n,line:i}=t;try{const t="function"==typeof s?s():s,o=await t,r=this.equal(o,n);return{type:"test",gist:e,verdict:r?"pass":"fail",resolvedTestResult:o,expect:n,line:i}}catch(t){return{type:"test",gist:e,verdict:"error",resolvedTestResult:t,expect:n,line:i}}}#o(t){switch(t){case"pass":return"color:limegreen; font-weight:bold";case"fail":return"color:red; font-weight:bold";case"info":return"color:darkorange; font-weight:bold";case"error":return"color:fuchsia; font-weight:bold;";default:return"color:dodgerblue; font-weight:bold"}}#i(){try{throw Error("")}catch(t){if(!t.stack)return null;const e=t.stack.split("\n").find(t=>t.includes(this.metaURL));if(!e)return null;const s=e.indexOf(this.metaURL)+this.metaURL.length+1,n=e.lastIndexOf(":");return e.substring(s,n)}}#c(){const t=new CustomEvent("complete",{detail:{verdict:this.#e}});this.output.dispatchEvent&&this.output.dispatchEvent(t)}#l(t,e){if("console"!==this.output&&this.output instanceof HTMLElement){const s=new ProgressEvent("progress",{lengthComputable:!0,loaded:t,total:e});this.output.dispatchEvent(s)}}#r(t,e,s,n,i,o){if(this.onlyFailed&&"pass"===s)return;const r=this.#o(s),l=[`%c${s.toUpperCase()}`,r,e];"fail"===s||"pass"===s||"error"===s?"console"===t?(console.groupCollapsed(...l),console.log("Result:",n),console.log("Expected:",i),o&&console.log("Line:",o),console.groupEnd()):this.#u(e,s,n,i,o):"console"===t?console.log(...l):this.#u(e,s,n,i,o)}#u(t,e,s,n,i){const o={gist:t,verdict:e,result:s,expect:n,line:i};if(s instanceof Error)if(s.stack){const t=s.stack.split("\n");t.unshift(s.message),o.result=t}else o.result=s.message;const r=document.createElement("output");r.value=JSON.stringify(o,null,2),this.output.append(r)}get output(){return this.#t}set output(t){let e;if("console"===t)this.#t="console";else if(t instanceof HTMLElement)this.#t=t;else{if(!(e=document.querySelector(t)))throw new Error(`Cannot find output target: ${t} `);this.#t=e}}get finalVerdict(){return this.#e}}export{t as default};
